<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>CodePen - US Federal Tax Bill - Corticon.js Dynamic Forms</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="./style.css">

</head>
<body>
<!-- partial:index.partial.html -->
<html>

<head>
  <meta charset="utf-8" />
  <title>Dynamic Questions Demo</title>

  <!-- From https://releases.jquery.com/ -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

  <script>
    // Assumption: jquery has been included and is defined.
    // Add a corticon "namespace" under window object and a namespace function to define our own sub-namespace
    (function() {
      if (window.corticon === undefined)
        window.corticon = {};
      // Define the util namespace for all utility functions.
      if (window.corticon.util === undefined)
        window.corticon.util = {};
      else
        throw "window.corticon.util should not be used by another jquery plugin";
      // if ( $.corticon === undefined )
      //     $.corticon = {};
      //
      // // Define the util namespace for all utility functions.
      // if ( $.corticon.util === undefined )
      //     $.corticon.util = {};
      // else
      //     throw "jquery.corticon.util should not be used by another jquery plugin";
      //
      /**
       * usage: jQuery.corticon.util.namespace( corticon.xyz );
       * or $.corticon.util.namespace( corticon.xyz );
       * Multiple namespaces can be defined in one call: or $.corticon.util.namespace( corticon.xyz corticon.abc );
       */
      window.corticon.util.namespace = function() {
        /* inspired by http://stackoverflow.com/questions/527089/is-it-possible-to-create-a-namespace-in-jquery */
        var a = arguments,
          o = null,
          i, j, d;
        for (i = 0; i < a.length; i = i + 1) {
          d = a[i].split(".");
          o = window;
          for (j = 0; j < d.length; j = j + 1) {
            o[d[j]] = o[d[j]] || {};
            o = o[d[j]];
          }
        }
        // console.log( JSON.stringify(window.corticon) );
      };
      window.corticon.util.copyToClipboard = function(selector) {
        const text = $(selector).val();
        // navigator.permissions.query({name: "clipboard-write"}).then(result => {
        //     if (result.state == "granted" || result.state == "prompt") {
        //         /* write to the clipboard now */
        //         console.log("should work now");
        //         navigator.clipboard.writeText(text).then(function(result) {
        //             /* clipboard successfully set */
        //         }, function(result) {
        //             console.log("Still Could not copy to clipboard - probably no privs to do that in this browser !"+result);
        //         });
        //     }
        // });
        navigator.clipboard.writeText(text).then(function(result) {
          /* clipboard successfully set */
        }, function(result) {
          console.log("Could not copy to clipboard - probably no privs to do that in this browser !" + result);
        });
      }
    })();
  </script>
  <script>
    corticon.util.namespace("corticon.dynForm");
    (function() {
      //https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events
      corticon.dynForm.customEvents = {
        "BEFORE_START": "beforeStart",
        "AFTER_START": "afterStart",
        "AFTER_DONE": "afterDone",
        "NEW_STEP": "newStep",
        "NEW_FORM_DATA_SAVED": "newFormDataSaved", // Some data were saved to the form data storage
        "NEW_DS_EXECUTION": "newDSExecution", // A decision service was executed - data will contain the output
        "BEFORE_DS_EXECUTION": "beforeDSExecution", // A decision service is about to be executed - data will contain the input
      }
      corticon.dynForm.addCustomEventHandler = function(name, fct) {
        // Listen for the event on the body element for the lack of a better element !.
        document.body.addEventListener(name, fct, false);
      }
      corticon.dynForm.raiseEvent = function(name, data) {
        const event = new Event(name);
        // I found that on some browsers, I couldn't get at detail as documented const event = new CustomEvent('build', { detail: elem.dataset.time });
        // So using my own field to store the data
        event.theData = data;
        document.body.dispatchEvent(event);
      }
    })(); // Immediately invoke to have the equivalent of a static class
  </script>

  <script>
    corticon.util.namespace("corticon.tracer");

    function Tracer() {
      // private section
      let itsStagesTrace = [];

      function setupTracing() {
        corticon.dynForm.addCustomEventHandler(corticon.dynForm.customEvents.BEFORE_START, _clearTraceData);
        corticon.dynForm.addCustomEventHandler(corticon.dynForm.customEvents.NEW_FORM_DATA_SAVED, _traceFormData);
        corticon.dynForm.addCustomEventHandler(corticon.dynForm.customEvents.BEFORE_DS_EXECUTION, _traceDecisionServiceInputs);
        corticon.dynForm.addCustomEventHandler(corticon.dynForm.customEvents.NEW_DS_EXECUTION, _traceDecisionServiceResults);
        corticon.dynForm.addCustomEventHandler(tracerCustomEvents.SWITCH_TO_SAVED_STAGE, _switchToSavedStage);
      }

      function _clearTraceData() {
        document.getElementById("decisionServiceInputId").value = "";
        document.getElementById("decisionServiceResultId").value = "";
        document.getElementById("formDataId").value = "";
        itsStagesTrace = [];
        $("#traceHistoryId").empty();
      }

      function _traceDecisionServiceInputs(event) {
        const theData = event.theData;
        const input = theData.input;
        const stage = theData.stage;
        const index = itsStagesTrace.length;
        const x = JSON.stringify(input, null, 2);
        itsStagesTrace[index] = {
          "input": x,
          "result": null,
          "formData": null
        };
        _showDecisionServiceInputs(x);
        _addStageInHistory(stage, index);
      }

      function _traceDecisionServiceResults(event) {
        const theData = event.theData;
        const result = theData.output;
        const execTimeMs = theData.execTimeMs;
        // we assume there was a call to trace the input and thus a new element in history
        const index = itsStagesTrace.length - 1;
        itsStagesTrace[index].result = JSON.stringify(result, null, 2);
        itsStagesTrace[index].timing = Math.round(execTimeMs);
        _showDecisionServiceResults(itsStagesTrace[index].result, itsStagesTrace[index].timing);
      }

      function _showDecisionServiceInputs(newValue) {
        document.getElementById("decisionServiceInputId").value = newValue;
      }

      function _removeHighlightedStage() {
        $(".stageInTrace").removeClass("activeStageInTrace");
      }

      function _addStageInHistory(stage, index) {
        _removeHighlightedStage();
        let html = `<span>`;
        if (index !== 0)
          html += `&rarr;`
        html += `<a class="activeStageInTrace stageInTrace" href="#" onclick="tracerClickStage(${index}, this)">&nbsp;${stage}&nbsp;</a></span>`
        $("#traceHistoryId").append(html);
        const newTitle = "Stages History: " + itsStagesTrace.length + " stages";
        $("#traceHistorySummaryId").prop("title", newTitle);
      }

      function _traceFormData(event) {
        const theData = event.theData;
        const index = itsStagesTrace.length - 1;
        const x = JSON.stringify(theData, null, 2);
        itsStagesTrace[index].formData = x;
        _showSavedFormData(x);
      }

      function _switchToSavedStage(event) {
        const index = event.theData.index;
        const theEl = event.theData.el;
        _removeHighlightedStage();
        $(theEl).addClass("activeStageInTrace");
        const oneTrace = itsStagesTrace[index];
        _showDecisionServiceInputs(oneTrace.input);
        _showDecisionServiceResults(oneTrace.result, oneTrace.timing);
        _showSavedFormData(oneTrace.formData);
      }

      function _showDecisionServiceResults(newValue, execTimeMs) {
        document.getElementById("decisionServiceResultId").value = newValue;
        $("#execTimeId").html("(" + execTimeMs + "ms)");
      }

      function _showSavedFormData(newValue) {
        if (newValue === null || newValue.length === 0)
          newValue = "Form Data was not saved at that step";
        document.getElementById("formDataId").value = newValue;
      }
      return {
        setupTracing: setupTracing
      }
    }
    const tracerCustomEvents = {
      "SWITCH_TO_SAVED_STAGE": "switchToSavedStage",
    }

    function tracerClickStage(index, theEl) {
      corticon.dynForm.raiseEvent(tracerCustomEvents.SWITCH_TO_SAVED_STAGE, {
        "index": index,
        "el": theEl
      });
    }
  </script>
  <script>
    corticon.util.namespace("corticon.dynForm");
    corticon.dynForm.UIControlsRenderer = function() {
      // TODO:
      // Number field as integer vs decimal -> new field type?
      // Render all UI Controls into the specified basedEl (A Jquery object - typically from a div element)
      // Render all Containers in base element
      // Render all Controls in container element
      // This is the main public entry point
      function renderUI(containers, baseEl, labelPositionAtUILevel, language) {
        /* Without JQuery one could create all dynamic elements just using the DOM API.  For example:
        var contEl = document.createElement('div');
        contEl.setAttribute('id', containers[0].id);
        contEl.appendChild(document.createTextNode(containers[0].title));
        document.getElementById('theDynamicUIContainerId').appendChild(contEl);
        */
        // Start with clean component - that is without any UI Controls from previous steps
        baseEl.empty();
        const html = '<div id="' + containers[0].id + '"  title="' + containers[0].title + '"><h3>' + containers[0].title + '</h3></div>';
        baseEl.append(html);
        const uiControls = containers[0].uiControls;
        if (uiControls === undefined || uiControls === null) {
          alert('There are no UI Controls to render in this step');
          return;
        }
        for (var i = 0; i < uiControls.length; i++) {
          const oneUIControl = uiControls[i];
          if (oneUIControl.type === 'Text')
            renderTextInput(oneUIControl, baseEl, labelPositionAtUILevel);
          else if (oneUIControl.type === 'TextArea')
            renderTextAreaInput(oneUIControl, baseEl, labelPositionAtUILevel);
          else if (oneUIControl.type === 'DateTime')
            renderDateTimeInput(oneUIControl, baseEl, labelPositionAtUILevel);
          else if (oneUIControl.type === 'YesNo')
            renderYesNoInput(oneUIControl, baseEl, labelPositionAtUILevel, language);
          else if (oneUIControl.type === 'ReadOnlyText')
            renderReadOnlyText(oneUIControl, baseEl, labelPositionAtUILevel);
          else if (oneUIControl.type === 'Number')
            renderNumberInput(oneUIControl, baseEl, labelPositionAtUILevel);
          else if (oneUIControl.type === 'SingleChoice')
            renderSingleChoiceInput(oneUIControl, baseEl);
          else if (oneUIControl.type === 'MultipleChoices')
            renderMultipleChoicesInput(oneUIControl, baseEl, labelPositionAtUILevel);
          else if (oneUIControl.type === 'MultiExpenses')
            renderExpenseInput(oneUIControl, baseEl, labelPositionAtUILevel);
          else if (oneUIControl.type === 'FileUpload')
            renderFileUploadInput(oneUIControl, baseEl, labelPositionAtUILevel);
          else
            alert('This ui control is not yet supported: ' + oneUIControl.type);
        }
        renderContainerValidationMessage(containers[0].validationMsg, baseEl);
        const allFormEls = $(baseEl).find(':input');
        if (allFormEls !== null && allFormEls.length > 0)
          allFormEls[0].focus();
      }
      // Begin expense
      let nextExpenseId = 0;

      function renderExpenseInput(oneUIControl, baseEl, labelPositionAtContainerLevel) {
        const html = '<div class="expenseInputContainer"></div>';
        const expenseContainerEl = $(html);
        baseEl.append(expenseContainerEl);
        appendLabel(oneUIControl, labelPositionAtContainerLevel, expenseContainerEl);
        createOneExpenseInput(oneUIControl, expenseContainerEl);
        createAddExpenseControl(baseEl, oneUIControl, expenseContainerEl);
        addValidationMsgFromDecisionService(oneUIControl, expenseContainerEl);
      }

      function createAddExpenseControl(baseEl, oneUIControl, expenseContainerEl) {
        const html = '<div title="Add another expense" class="addExpenseContainer">&nbsp;+&nbsp;</div>';
        const addContainerEl = $(html);
        baseEl.append(addContainerEl);
        addContainerEl.click(function() {
          createOneExpenseInput(oneUIControl, expenseContainerEl);
        });
      }

      function createOneExpenseInput(oneUIControl, expenseContainerEl) {
        nextExpenseId++;
        const inputContainerEl = createInputContainer(expenseContainerEl, true);
        inputContainerEl.data("uicontroltype", oneUIControl.type); // save it so that we can conditionally add the proper fields when creating the expense object literal in the stepsController.js
        let htmlExpenseType = `<select "id": ${oneUIControl.id}_expType_${nextExpenseId}>`;
        const theOptions = oneUIControl.option;
        if (theOptions === undefined || theOptions === null) {
          alert("Missing options for " + oneUIControl.id);
        } else {
          if (theOptions.length > 0) {
            for (var i = 0; i < theOptions.length; i++)
              htmlExpenseType += `<option value="${theOptions[i].value}">${theOptions[i].displayName}</option>`;
          } else
            alert('missing list of options for expense control ' + oneUIControl.id);
        }
        htmlExpenseType += '</select>';
        const expenseEl = $(htmlExpenseType);
        inputContainerEl.append(expenseEl);
        const theAttributes = {
          "type": "text",
          "id": `${oneUIControl.id}_expAmount_${nextExpenseId}`
        };
        const textInputEl = $('<input class="expenseAmount"/>').attr(theAttributes);
        textInputEl.appendTo(inputContainerEl);
        if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null) {
          textInputEl.data("fieldName", oneUIControl.fieldName);
          textInputEl.data("type", "array");
        } else
          alert('Missing field name for ' + oneUIControl.id);
        addCurrencyDropDown(oneUIControl, inputContainerEl);
      }

      function addCurrencyDropDown(oneUIControl, inputContainerEl) {
        let currency = `<select class="currencySelector" "id": ${oneUIControl.id}_Currency_${nextExpenseId}>`;
        currency += `<option value="USD">$ US Dollars</option>`;
        currency += `<option value="EUR">&euro; Euro</option>`;
        currency += '</select>';
        const currencyEl = $(currency);
        currencyEl.data("fieldName", oneUIControl.fieldName);
        inputContainerEl.append(currencyEl);
      }
      // End expense
      function renderSingleChoiceInput(oneUIControl, baseEl) {
        const inputContainerEl = createInputContainer(baseEl);
        if (oneUIControl.label !== undefined && oneUIControl.label !== null) {
          const theAttributes = {
            "type": "checkbox",
            "id": oneUIControl.id,
            "name": oneUIControl.id
          };
          const checkboxInputEl = $('<input/>').attr(theAttributes);
          checkboxInputEl.appendTo(inputContainerEl);
          const checkboxLabelEl = $(`<label for="${oneUIControl.id}">&nbsp;${oneUIControl.label}</label>`)
          checkboxLabelEl.appendTo(inputContainerEl);
          if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null)
            checkboxInputEl.data("fieldName", oneUIControl.fieldName);
          else
            alert('Missing field name for ' + oneUIControl.id);
        } else
          alert('Missing label for checkbox ' + oneUIControl.id);
      }

      function renderFileUploadInput(oneUIControl, baseEl, labelPositionAtContainerLevel) {
        const inputContainerEl = createInputContainer(baseEl);
        if (oneUIControl.id === undefined || oneUIControl.id === null) {
          alert('missing id for fileupload ');
          return;
        }
        /*
        <form action="/action_page.php">
          <input type="file" id="myFile" name="filename">
          <input type="submit">
        </form>

        <label for="fileUpId">Choose a file:</label>
        <input type="file" id="fileUpId" name="xyz">
         */
        if (oneUIControl.label === undefined || oneUIControl.label === null || oneUIControl.label.length === 0) {
          alert('missing label for fileupload ' + oneUIControl.id);
          return;
        }
        const fileUpHtml = `<label htmlFor="${oneUIControl.id}">${oneUIControl.label}:</label>
								<input type="file" id="${oneUIControl.id}">`;
        const fileUpEl = $(fileUpHtml);
        inputContainerEl.append(fileUpEl);
        if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null)
          fileUpEl.data("fieldName", oneUIControl.fieldName);
        else
          alert('Missing field name for ' + oneUIControl.id);
      }

      function renderTextInput(oneUIControl, baseEl, labelPositionAtContainerLevel) {
        const inputContainerEl = createInputContainer(baseEl);
        appendLabel(oneUIControl, labelPositionAtContainerLevel, inputContainerEl);
        const theAttributes = {
          "type": "text",
          "id": oneUIControl.id
        };
        if (oneUIControl.tooltip !== undefined && oneUIControl.tooltip !== null)
          theAttributes["title"] = oneUIControl.tooltip;
        const textInputEl = $('<input/>').attr(theAttributes);
        textInputEl.appendTo(inputContainerEl);
        if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null)
          textInputEl.data("fieldName", oneUIControl.fieldName);
        else
          alert('Missing field name for ' + oneUIControl.id);
        addValidationMsgFromDecisionService(oneUIControl, inputContainerEl);
      }

      function renderTextAreaInput(oneUIControl, baseEl, labelPositionAtContainerLevel) {
        const inputContainerEl = createInputContainer(baseEl);
        appendLabel(oneUIControl, labelPositionAtContainerLevel, inputContainerEl);
        let html3 = `<textarea class="textAreaControl" id="${oneUIControl.id}"`;
        if (oneUIControl.rows !== undefined && oneUIControl.rows !== null)
          html3 += ` rows="${oneUIControl.rows}"`;
        if (oneUIControl.cols !== undefined && oneUIControl.cols !== null)
          html3 += ` cols="${oneUIControl.cols}"`;
        if (oneUIControl.min !== undefined && oneUIControl.min !== null)
          html3 += ` minlength="${oneUIControl.min}"`;
        if (oneUIControl.max !== undefined && oneUIControl.max !== null)
          html3 += ` maxlength="${oneUIControl.max}"`;
        html3 += `></textarea>`;
        const textInputEl = $(html3);
        textInputEl.appendTo(inputContainerEl);
        if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null)
          textInputEl.data("fieldName", oneUIControl.fieldName);
        else
          alert('Missing field name for ' + oneUIControl.id);
        addValidationMsgFromDecisionService(oneUIControl, inputContainerEl);
      }

      function renderDateTimeInput(oneUIControl, baseEl, labelPositionAtContainerLevel) {
        const inputContainerEl = createInputContainer(baseEl);
        appendLabel(oneUIControl, labelPositionAtContainerLevel, inputContainerEl);
        const theAttributes = {
          "type": "date",
          "id": oneUIControl.id
        };
        if (oneUIControl.minDT !== undefined && oneUIControl.minDT !== null)
          theAttributes['min'] = oneUIControl.minDT;
        if (oneUIControl.maxDT !== undefined && oneUIControl.maxDT !== null)
          theAttributes['max'] = oneUIControl.maxDT;
        const textInputEl = $('<input/>').attr(theAttributes);
        textInputEl.appendTo(inputContainerEl);
        if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null)
          textInputEl.data("fieldName", oneUIControl.fieldName);
        else
          alert('Missing field name for ' + oneUIControl.id);
        if (oneUIControl.minDT !== undefined && oneUIControl.minDT !== null) {
          const html3 = '<span  class="fieldValidationLabel">Enter a date between ' + oneUIControl.minDT.substr(0, 10) + ' and ' + oneUIControl.maxDT.substr(0, 10) + '</span>';
          const validationEl = $(html3);
          inputContainerEl.append(validationEl);
        }
        addValidationMsgFromDecisionService(oneUIControl, inputContainerEl);
      }

      function renderNumberInput(oneUIControl, baseEl, labelPositionAtContainerLevel) {
        const inputContainerEl = createInputContainer(baseEl);
        appendLabel(oneUIControl, labelPositionAtContainerLevel, inputContainerEl);
        const html3 = '<span style="display: none;" class="fieldValidationLabel">Enter a number between ' + oneUIControl.min + ' and ' + oneUIControl.max + '</span>';
        const validationEl = $(html3);
        const theAttributes = {
          "type": "text",
          "id": oneUIControl.id
        };
        const textInputEl = $('<input/>').attr(theAttributes);
        textInputEl.appendTo(inputContainerEl);
        if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null) {
          textInputEl.data("fieldName", oneUIControl.fieldName);
          textInputEl.data("type", "decimal"); //todo: should add an attrib for doing integer too
        } else
          alert('Missing field name for ' + oneUIControl.id);
        // there may be a value (default value or when validation fails we re-render with entered data)
        if (oneUIControl.value !== undefined && oneUIControl.value !== null) {
          textInputEl.val(oneUIControl.value);
        }
        textInputEl.on("input", function() {
          const input = $(this).val();
          const converted = Number(input);
          if (isNaN(converted))
            alert("Please enter a number");
          else {
            if (converted < oneUIControl.min || converted > oneUIControl.max)
              validationEl.fadeOut(100).fadeIn(100).fadeOut(100).fadeIn(100);
          }
        });
        inputContainerEl.append(validationEl);
        addValidationMsgFromDecisionService(oneUIControl, inputContainerEl);
        if (oneUIControl.min !== undefined)
          validationEl.show();
      }

      function renderReadOnlyText(oneUIControl, baseEl, labelPositionAtContainerLevel) {
        const inputContainerEl = createInputContainer(baseEl);
        appendLabel(oneUIControl, labelPositionAtContainerLevel, inputContainerEl);
        if (oneUIControl.value !== undefined && oneUIControl.value !== null && oneUIControl.value.length !== 0) {
          const html3 = '<div class="readOnlyText">' + oneUIControl.value + '</div>';
          inputContainerEl.append($(html3));
        } else
          alert("missing value attribute for renderReadOnlyText id: " + oneUIControl.id);
      }

      function renderYesNoInput(oneUIControl, baseEl, labelPositionAtContainerLevel, language) {
        const inputContainerEl = createInputContainer(baseEl);
        let yes = 'Yes';
        let no = 'No';
        if (language !== undefined && language !== null) {
          if (language.toLowerCase() === 'italian') {
            yes = 'Si';
          }
        }
        appendLabel(oneUIControl, labelPositionAtContainerLevel, inputContainerEl);
        const html3 = `<select "id": ${oneUIControl.id}>
                        <option value="yes">${yes}</option>
                        <option value="no">${no}</option>
                </select>`;
        const yesNoEl = $(html3);
        if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null)
          yesNoEl.data("fieldName", oneUIControl.fieldName);
        else
          alert('Missing field name for ' + oneUIControl.id);
        inputContainerEl.append(yesNoEl);
      }

      function renderMultipleChoicesInput(oneUIControl, baseEl, labelPositionAtContainerLevel) {
        const inputContainerEl = createInputContainer(baseEl);
        appendLabel(oneUIControl, labelPositionAtContainerLevel, inputContainerEl);
        let html3 = `<select "id": ${oneUIControl.id}>`;
        const theOptions = oneUIControl.option;
        if (theOptions === undefined || theOptions === null) {
          alert("Missing options for " + oneUIControl.id);
        } else {
          if (theOptions.length > 0) {
            for (var i = 0; i < theOptions.length; i++)
              html3 += `<option value="${theOptions[i].value}">${theOptions[i].displayName}</option>`;
          } else
            alert('missing list of options for multiple choices control ' + oneUIControl.id);
        }
        html3 += '</select>';
        const multipleChoicesEl = $(html3);
        if (oneUIControl.fieldName !== undefined && oneUIControl.fieldName !== null)
          multipleChoicesEl.data("fieldName", oneUIControl.fieldName);
        else
          alert('Missing field name for ' + oneUIControl.id);
        inputContainerEl.append(multipleChoicesEl);
        addValidationMsgFromDecisionService(oneUIControl, inputContainerEl);
      }

      function renderContainerValidationMessage(validationMessage, baseEl) {
        if (validationMessage !== undefined && validationMessage !== null) {
          const html = `<div class="containerValidationMessage">${validationMessage}</div>`;
          const msgEl = $(html);
          baseEl.append(msgEl);
        }
      }

      function createInputContainer(baseEl, arrayTypeControl = false) {
        let html;
        if (arrayTypeControl)
          html = '<div class="arrayTypeControl inputContainer"></div>'; //arrayTypeControl: this is needed as the marker for finding the inputs that have to be stored in an array as opposed to directly in a field.
        else
          html = '<div class="nonarrayTypeControl inputContainer"></div>';
        const inputContainerEl = $(html);
        baseEl.append(inputContainerEl);
        return inputContainerEl;
      }

      function addValidationMsgFromDecisionService(oneUIControl, inputContainerEl) {
        if (oneUIControl.validationErrorMsg !== undefined && oneUIControl.validationErrorMsg !== null) {
          const decisionServiceSideValidationEl = $(`<span class="controlValidationMessage">${oneUIControl.validationErrorMsg}</span>`);
          decisionServiceSideValidationEl.appendTo(inputContainerEl);
        }
      }

      function getLabelPositionForControl(oneUIControl, labelPositionAtContainerLevel) {
        let labelPosition;
        if (oneUIControl.labelPosition !== undefined && oneUIControl.labelPosition !== null)
          labelPosition = oneUIControl.labelPosition;
        else
          labelPosition = labelPositionAtContainerLevel;
        return labelPosition;
      }

      function appendLabel(oneUIControl, labelPositionAtContainerLevel, inputContainerEl) {
        if (oneUIControl.label !== undefined && oneUIControl.label !== null) {
          let html2;
          const labelPosition = getLabelPositionForControl(oneUIControl, labelPositionAtContainerLevel);
          if (labelPosition === 'Above')
            html2 = '<div class="inputLabelAbove">' + oneUIControl.label + '</div>';
          else
            html2 = '<span class="inputLabelSide">' + oneUIControl.label + '</span>';
          inputContainerEl.append($(html2));
        }
      }
      // public interface
      return {
        renderUI: renderUI,
      }
    }
  </script>
  <script>
    corticon.util.namespace("corticon.dynForm");
    corticon.dynForm.StepsController = function() {
      // We maintain the state of the multi-steps UI in these variables
      // An array with 2 elements:
      // First element is for the UI containers and controls, the second element is for storing all form data
      let itsDecisionServiceInput = [{}, {}];
      let itsPathToData;
      let itsFormData;
      let itsFlagAllDone;
      let itsLabelPositionAtUILevel;
      const itsUIControlsRenderer = new corticon.dynForm.UIControlsRenderer();

      function startDynUI(baseDynamicUIEl, decisionServiceEngine, externalData, language) {
        _resetDecisionServiceInput(language);
        _resetState();
        // We do a deep Copy of externalData.  We need to do that to be able to start more than once
        // (if we don't copy, _resetDecisionServiceInput will erase the original externalData)
        itsDecisionServiceInput[1] = JSON.parse(JSON.stringify(externalData));
        corticon.dynForm.raiseEvent(corticon.dynForm.customEvents.BEFORE_START);
        _askDecisionServiceForNextUIElementsAndRender(decisionServiceEngine, itsDecisionServiceInput, baseDynamicUIEl);
        corticon.dynForm.raiseEvent(corticon.dynForm.customEvents.AFTER_START);
      }

      function processNextStep(baseDynamicUIEl, decisionServiceEngine, language) {
        // On Next click, copy value of all rendered elements to the UI Controls in payload
        _saveEnteredInputsToFormData(baseDynamicUIEl);
        corticon.dynForm.raiseEvent(corticon.dynForm.customEvents.NEW_STEP);
        // If previous call to decision service returned done then reset ui to restart and in this sample we just display the form data in debug panel
        if (itsFlagAllDone) {
          corticon.dynForm.raiseEvent(corticon.dynForm.customEvents.AFTER_DONE);
        } else {
          _preparePayloadForNextStage(itsDecisionServiceInput[0].nextStageNumber, language);
          let nextUI = _askDecisionServiceForNextUIElementsAndRender(decisionServiceEngine, itsDecisionServiceInput, baseDynamicUIEl);
          // Execute all the steps that are just computation steps till we get a step that require rendering (in which case we will wait for user input and click next)
          while (nextUI.noUiToRenderContinue !== undefined && nextUI.noUiToRenderContinue) {
            _preparePayloadForNextStage(nextUI.nextStageNumber);
            nextUI = _askDecisionServiceForNextUIElementsAndRender(decisionServiceEngine, itsDecisionServiceInput, baseDynamicUIEl);
            corticon.dynForm.raiseEvent(corticon.dynForm.customEvents.NEW_FORM_DATA_SAVED, itsFormData);
            if (nextUI.done) // if last step is a computation step
              break;
          }
          itsFlagAllDone = nextUI.done;
        }
      }

      function _resetDecisionServiceInput(language) {
        _preparePayloadForNextStage(0, language);
        for (const property in itsDecisionServiceInput[1]) // clear all previous form data if any
          delete itsDecisionServiceInput[1][property];
      }

      function _preparePayloadForNextStage(nextStage, language) {
        for (const property in itsDecisionServiceInput[0]) // clear all previous step data except stageOnExit
        {
          if (property !== 'stageOnExit')
            delete itsDecisionServiceInput[0][property];
        }
        itsDecisionServiceInput[0].currentStageNumber = nextStage;
        itsDecisionServiceInput[0].language = language;
      }

      function _resetState() {
        itsFormData = null;
        itsFlagAllDone = false;
        itsPathToData = null;
        itsLabelPositionAtUILevel = "Above"; // Default
      }

      function _processLabelPositionSetting(newLabelPosition) {
        // If rule sends a new position uses it - otherwise we will just use the default or whatever was set at a previous step
        if (newLabelPosition !== undefined && newLabelPosition !== null)
          itsLabelPositionAtUILevel = newLabelPosition;
      }

      function _askDecisionServiceForNextUIElementsAndRender(decisionServiceEngine, payload, baseEl) {
        const result = _runDecisionService(decisionServiceEngine, payload);
        const nextUI = result.payload[0];
        // Save context of where we need to save data the user enters so that rule modeler does not have to specify it at each step.
        if (nextUI.pathToData !== undefined && nextUI.pathToData !== null && nextUI.pathToData.length !== 0)
          itsPathToData = nextUI.pathToData;
        // Save the default label position so that rule modeler does not have to specify it at each step.
        _processLabelPositionSetting(nextUI.labelPosition);
        // Save state: the decision service could potentially augment the form data with computed values that we want to keep carrying around.
        itsFormData = itsDecisionServiceInput[1];
        // Check if this step was just a computation step in which case we just continue as there is no ui to display
        if (nextUI.noUiToRenderContinue !== undefined && nextUI.noUiToRenderContinue)
          return nextUI;
        const containers = nextUI.containers;
        if (containers === undefined) {
          alert('Error: missing container');
          return nextUI;
        }
        itsUIControlsRenderer.renderUI(containers, baseEl, itsLabelPositionAtUILevel, nextUI.language);
        return nextUI;
      }

      function _saveOneFormData(formDataFieldName, val) {
        if (val === undefined)
          return;
        if (itsPathToData === undefined || itsPathToData === null)
          itsFormData[formDataFieldName] = val;
        else {
          if (itsFormData[itsPathToData] === undefined)
            itsFormData[itsPathToData] = {};
          itsFormData[itsPathToData][formDataFieldName] = val;
        }
      }

      function _saveNonArrayInputsToFormData(baseEl) {
        // With space in selector we get all descendants.
        // There's a difference between $("#panel input") and $("#panel :input).
        // The first one will only retrieve elements of type input, that is <input type="...">, but not <textarea>, <button> and <select> elements.
        // let allFormEls = $('#dynUIContainerId :input').not('#dynUIContainerId :checkbox');
        let allFormEls = baseEl.find('.nonarrayTypeControl :input').not(':checkbox');
        allFormEls.each(function(index, item) {
          const oneInputEl = $(item);
          const formDataFieldName = oneInputEl.data("fieldName");
          const val = oneInputEl.val();
          const type = oneInputEl.data("type");
          if (type !== undefined && type !== null && type === "decimal") {
            const converted = Number(val);
            if (isNaN(converted))
              alert("you didn't enter a number in the field");
            else
              _saveOneFormData(formDataFieldName, converted);
          } else
            _saveOneFormData(formDataFieldName, val);
        });
        // allFormEls = $('#dynUIContainerId :checkbox');
        allFormEls = baseEl.find('.nonarrayTypeControl :checkbox');
        allFormEls.each(function(index, item) {
          const oneInputEl = $(item);
          const formDataFieldName = oneInputEl.data("fieldName");
          const val = oneInputEl.is(':checked');
          _saveOneFormData(formDataFieldName, val);
        });
      }

      function _saveEnteredInputsToFormData(baseEl) {
        _saveNonArrayInputsToFormData(baseEl);
        _saveArrayTypeInputsToFormData(baseEl);
        corticon.dynForm.raiseEvent(corticon.dynForm.customEvents.NEW_FORM_DATA_SAVED, itsFormData);
      }

      function _saveArrayTypeInputsToFormData(baseEl) {
        let outerArray = [];
        let formDataFieldName;
        let uiControlType;
        let allArrayEls = baseEl.find('.arrayTypeControl');
        allArrayEls.each(function(index, item) {
          const oneArrayEl = $(item);
          uiControlType = oneArrayEl.data("uicontroltype");
          let allFormEls = oneArrayEl.find(':input').not(':checkbox');
          let innerArray = [];
          for (var i = 0; i < allFormEls.length; i++) {
            const oneFormEl = allFormEls[i];
            const oneInputEl = $(oneFormEl);
            formDataFieldName = oneInputEl.data("fieldName");
            const val = oneInputEl.val();
            innerArray.push(val);
          }
          outerArray.push(innerArray);
        });
        if (outerArray.length !== 0) {
          if (uiControlType === 'MultiExpenses') {
            const expenseFieldArray = ['expenseCode', 'amount', 'currency'];
            const convertedArray = _createEachExpenseEntity(outerArray, expenseFieldArray);
            _saveArrayElFormData(formDataFieldName, convertedArray);
          } else
            alert('This array type is not yet supported ' + uiControlType);
        }
      }

      function _createEachExpenseEntity(outerArray, expenseFieldArray) {
        const convertedArray = [];
        for (var i = 0; i < outerArray.length; i++) {
          const oneItemAsAnArray = outerArray[i];
          const oneItemAsObjLit = {};
          for (var j = 0; j < oneItemAsAnArray.length; j++) {
            oneItemAsObjLit[expenseFieldArray[j]] = oneItemAsAnArray[j];
          }
          const converted = Number(oneItemAsObjLit['amount']);
          if ($.isNumeric(converted))
            oneItemAsObjLit['amount'] = converted;
          else
            oneItemAsObjLit['amount'] = 0;
          convertedArray.push(oneItemAsObjLit);
        }
        return convertedArray;
      }

      function _saveArrayElFormData(formDataFieldName, outerArray) {
        if (outerArray === undefined)
          return;
        if (itsPathToData === undefined || itsPathToData === null)
          itsFormData[formDataFieldName] = outerArray;
        else {
          if (itsFormData[itsPathToData] === undefined)
            itsFormData[itsPathToData] = {};
          itsFormData[itsPathToData][formDataFieldName] = outerArray;
        }
      }

      function _runDecisionService(decisionServiceEngine, payload) {
        try {
          corticon.dynForm.raiseEvent(corticon.dynForm.customEvents.BEFORE_DS_EXECUTION, {
            "input": payload,
            "stage": payload[0].currentStageNumber
          });
          // const configuration = { logLevel: 0 };
          const configuration = {
            logLevel: 1
          };
          const t1 = performance.now();
          const result = decisionServiceEngine.execute(payload, configuration);
          const t2 = performance.now();
          corticon.dynForm.raiseEvent(corticon.dynForm.customEvents.NEW_DS_EXECUTION, {
            "output": result,
            "execTimeMs": t2 - t1,
            "stage": payload[0].currentStageNumber
          });
          if (result.corticon !== undefined) {
            if (result.corticon.status === 'success')
              return result;
            else
              alert('There was an error executing the rules.\n' + JSON.stringify(result, null, 2));
          } else
            alert('There was an error executing the rules.\n' + JSON.stringify(result, null, 2));
        } catch (e) {
          alert('There was an exception executing the rules ' + e);
        }
      }
      // Public interface
      return {
        startDynUI: startDynUI,
        processNextStep: processNextStep
      }
    }
  </script>

  <!-- To see these icons or search for some see: https://icons.getbootstrap.com/ -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">

  <script>
    let currentDecisionServiceEngine;
    let allInputData = [];
    let inputData; // per decision service set of data to pass all along
    let itsCurrentLanguage = 'english';
    const itsTracer = new Tracer();
    const itsStepsController = new corticon.dynForm.StepsController();

    function processSwitchSample(selectObject) {
      const index = selectObject.value;
      currentDecisionServiceEngine = window.corticonEngines[index];
      inputData = allInputData[index];
      if (index === "5")
        $("#languageContainerId").show();
      else
        $("#languageContainerId").hide();
    }

    function processSwitchLanguage(selectObject) {
      itsCurrentLanguage = selectObject.value;
    }

    function processClickStart() {
      const baseDynamicUIEl = $('#dynUIContainerId');
      itsStepsController.startDynUI(baseDynamicUIEl, currentDecisionServiceEngine, inputData, itsCurrentLanguage);
    }

    function processClickNext() {
      const baseDynamicUIEl = $('#dynUIContainerId');
      itsStepsController.processNextStep(baseDynamicUIEl, currentDecisionServiceEngine, itsCurrentLanguage);
    }

    function saveStateButton(show) {
      // save it in local storage for restore  on reload
      try {
        window.localStorage.setItem('CorticonShowDSTrace', show);
      } catch (e) {
        // Some browser in private mode may throw exception when using local storage
      }
    }

    function processShowTrace() {
      const traceEl = $('.allTracesContainer');
      traceEl.show();
      $("#hideTraceId").show();
      $("#showTraceId").hide();
      saveStateButton(true);
    }

    function processHideTrace() {
      const traceEl = $('.allTracesContainer');
      traceEl.hide();
      $("#showTraceId").show();
      $("#hideTraceId").hide();
      saveStateButton(false);
    }

    function setupInitialInputData() {
      const inDataTaxes = {};
      // Must correspond with the order of the DS inclusion
      allInputData.push(inDataTaxes);
      inputData = allInputData[0];
    }

    function restoreUIState() {
      const show = window.localStorage.getItem('CorticonShowDSTrace');
      if (show !== null) {
        if (show === 'true')
          processShowTrace();
        else if (show === 'false')
          processHideTrace();
      }
    }
    $(document).ready(function() {
      currentDecisionServiceEngine = window.corticonEngines[0];
      setupInitialInputData();
      itsTracer.setupTracing();
      restoreUIState();
      // addCustomEventHandler( BEFORE_START, () =>  );
      corticon.dynForm.addCustomEventHandler(corticon.dynForm.customEvents.AFTER_START, () => {
        $("#nextActionId").show();
        $("#startActionId").hide();
        $("#sampleSelectId").attr('disabled', true);
      });
      corticon.dynForm.addCustomEventHandler(corticon.dynForm.customEvents.AFTER_DONE, () => {
        $("#nextActionId").hide();
        $("#startActionId").show();
        $('#dynUIContainerId').html('<div style="margin: 2em; font-size: larger;">&nbsp;<i class="bi bi-check-circle"></i>All Done</div>');
        $("#sampleSelectId").attr('disabled', false);
      });
    });
  </script>
</head>

<body>
  <div class="sampleTitle"><i class="bi bi-file-earmark-ruled"></i>&nbsp;Test Driver for Rules Driven Dynamic Forms</div>

  <table width="100%">
    <tr>
      <td valign="top">
        <div class="commandBar">
          <div class="commandContainer">
            <div class="sampleSelectLabel">Select Sample:</div>
            <select class="sampleSelect" id="sampleSelectId" onchange="processSwitchSample(this)">
              <option value="1">Taxes</option>
            </select>
          </div>

          <div style="display: none;" id="languageContainerId">
            <div class="commandVerticalSpacer">&nbsp;</div>
            <div class="commandContainer">
              <!--						<div class="sampleSelectLabel">Select Language:</div>-->
              <select class="sampleSelect" id="languageSelectId" onchange="processSwitchLanguage(this)">
                <option value="english">English</option>
                <option value="italian">Italiano</option>
              </select>
            </div>
          </div>

          <div class="commandVerticalSpacer">&nbsp;</div>

          <div class="commandContainer">
            <span class="commandButton" id="startActionId">
              <a class="command" accesskey="s" title="Start Dynamic Form - Shortcut: Alt S (Windows) - CRTL Option S (Mac)" href="#" onclick="processClickStart(); return false;">
                <i style="padding-left: .3rem;" class="bi bi-box-arrow-in-right"></i>&nbsp;<span style="text-decoration: underline">S</span>tart
              </a>
            </span>
            <span class="commandButton commandButtonHidden" id="nextActionId">
              <a class="command" accesskey="n" title="Next Step - Shortcut: Alt N (Windows) - CRTL Option N (Mac)" href="#" onclick="processClickNext(); return false;">
                <i style="padding-left: .3rem;" class="bi bi-arrow-right-square"></i>&nbsp;<span style="text-decoration: underline">N</span>ext
              </a>
            </span>
          </div>

          <div class="commandContainer showTraceContainer">
            <span class="commandButton" id="showTraceId">
              <a class="command" accesskey="t" title="Start Dynamic Form - Shortcut: Alt T (Windows) - CRTL Option T (Mac)" href="#" onclick="processShowTrace(); return false;">
                &nbsp;Show <span style="text-decoration: underline">T</span>race
              </a>
            </span>
            <span class="commandButton commandButtonHidden" id="hideTraceId">
              <a class="command" accesskey="h" title="Hide Trace - Shortcut: Alt H (Windows) - CRTL Option H (Mac)" href="#" onclick="processHideTrace(); return false;">
                &nbsp;<span style="text-decoration: underline">H</span>ide Trace
              </a>
            </span>
          </div>
        </div>
      </td>
      <!--				<td width="98%">&nbsp;</td>-->
      <td width="100%">
        <div id="dynUIContainerId" class="dynUIContainer">
          <div>Dynamic Form component</div>
          <div style="margin: 2rem;">
            These samples show dynamic form (forms content is generated on the fly) where the form prompts are based on rules from Corticon.js decision services.
            It shows how the rules can drive a generic UI component to render all sorts of prompts or questions.
          </div>
        </div>
      </td>
    </tr>
  </table>

  <div class="allTracesContainer">
    <!--    <h3><i class="bi bi-layout-three-columns"></i>&nbsp;Decision Service (Rules) Trace Panel</h3>-->
    <div class="tracePanelTitle">Decision Service (Rules) Trace Panel</div>

    <div class="stageTraceHistory" style="overflow-x: auto; overflow-y: hidden; padding: 0.8rem;">
      <span style="width: 20px;" id="traceHistorySummaryId"><i class="bi bi-journal-text"></i></span>
      <span style="margin-left: 0.6rem;" id="traceHistoryId"></span>
    </div>
    <table width="100%">
      <tr>
        <td>
          <i class="bi bi-arrow-down-right-square"></i>&nbsp;Input to Decision Service Call <a href="#" title="Copy to clipboard" class="copyToClip" onclick="corticon.util.copyToClipboard('#decisionServiceInputId'); return false;">&nbsp;<i class="bi bi-clipboard-plus"></i></a>
        </td>
        <td>
          <i class="bi bi-arrow-up-left-square"></i>&nbsp;Results From Decision Service Call <span id="execTimeId"></span> <a href="#" title="Copy to clipboard" class="copyToClip" onclick="corticon.util.copyToClipboard('#decisionServiceResultId'); return false;">&nbsp;<i class="bi bi-clipboard-plus"></i></a>
        </td>
        <td>
          <i class="bi bi-clipboard-data"></i>&nbsp;Accrued Form Data <a href="#" title="Copy to clipboard" class="copyToClip" onclick="corticon.util.copyToClipboard('#formDataId'); return false;">&nbsp;<i class="bi bi-clipboard-plus"></i></a>
        </td>
      </tr>
      <tr>
        <td width="20%">
          <textarea style="width: 100%; height: 300px;" id="decisionServiceInputId"></textarea>
        </td>
        <td width="40%">
          <textarea style="width: 100%; height: 300px;" id="decisionServiceResultId"></textarea>
        </td>
        <td width="40%">
          <textarea style="width: 100%; height: 300px;" id="formDataId"></textarea>
        </td>
      </tr>
    </table>
  </div>
</body>

</html>
<!-- partial -->
  <script  src="./script.js"></script>

</body>
</html>
